- 계획
  - 22.01.24 ~    
  - 약 3주간 빠르게 리딩
  - 세세하게 보는 것은 나중에 시간여유가 더 생길 때

- Part 1
  - chp 1 : 기초문법, 기초적인 STL
    - c++의 기초적인 문법 요소와 STL 소개. 세세한 내용은 part 3에서 전개됨
  - chp 2 : 스트링
    - c++ 에서는 std::string 클래스를 사용
    - c++17 에서 추가된 std::string_view 클래스 소개
  - chp 3 : 코딩 스타일
    - 코딩 스타일은 프로젝트를 시작할 때 팀원끼리 공유할 스타일을 정해서 사용해라
    - 5 가지 중요 포인트
      - 문서화 : 주석을 적절하게 다는 법
      - 분할 : 열심히 코딩을 한 뒤에, 리팩토링을 통해 잘 쪼개라
      - 명명법 : 함수, 클래스, 변수 이름 짓는 법 몇 가지 추천
      - 언어의 기능 활용 : 매크로 상수 보단 const 상수, 포인터 대신 레퍼런스, 익셉션
      - 포매팅 : {} 위치, 연산의 앞뒤 띄어쓰기 등
- Part 2 // 실제로 OOP 경험을 쌓고나서 다시 읽어볼 것
  - chp 4 : 프로그램 디자인
    - 무작정 코딩을 시작하지 않고, 전체 설계도를 짜는게 왜 중요한지
    - 디자인 관련 2가지 중요 원칙
      - 추상화 : 구현(definition)와 인터페이스의 깔끔한 구분
      - 재사용 : 코드를 재사용 가능하게 짜는 법, 라이브러리/프레임워크 등 코드를 재사용할 때 고려사항
    - 오픈소스 라이브러리, C++ 표준 라이브러리
  - chp 5 : 객체지향
    - 절차형 사고방식 vs 객체지향형 사고방식
      - 절차형 : 프로그램이 어떤 일을 하는가?
          -  procedure 단위로 코드를 분할
      -  객체지향형 : 어떤 대상을 모델링 하는가?
          -  표현하고자하는 객체를 표현하고, 객체간의 상호작용으로 프로그램을 구성
          -  detail
              1. 특성(property)->member variable
              2. 구성요소(component)->member class
              3. 동작(behavior)->method
    - 객체간의 관계
      - has-a 관계 (ex : 칵테일 레서피 클래스는 사용되는 재료 객체를 포함)
      - is-a 관계 (ex : 봄베이, 고든스, 탱커레이는 '진'이라는 클래스를 상속 받고, 각자만의 특징을 추가함)
    - 잘 된 추상화란?
      - 인터페이스가 public method 만으로 구성됨
      - 인터페이스가 담겨 있는 헤더파일에는 선언만 있고, 모든 구현코드는 별도로 구분됨
      - property 가 information hiding 되어 있고, public method으로써 get_, set_ 을 제공해서 사용
      - 인터페이스가 해당 클래스의 사용자에 따라, 용도에 따라 적절하게 구현됨
  - chp 6 : 재사용을 고려한 디자인
    - 철학
      - 작성은 한 번, 재사용은 여러번
    - 내가 만든 코드를 라이브러리화 하려는 시도를 해본적이 없어서, 잘 와닿지 않았다. 나중에 다시 읽어보자.
- Part 5
  - chp 24 : 개발 프로세스
    - 

- 개인적으로 궁금했던거
    1. MFC가 뭔가?
       - Microsoft Foundation Class Library
       - window API를 c++에서 사용할 수 있게 만든 라이브러리
       - 윈도우OS의 커널API, 드라이버 같은 느낌?
       - 안정적인 프로그래밍이 가능, 다른 운영체제 포팅 가능, 손쉬운 GUI 제작 등
    2. pointer 와 reference 의 차이?
       - 레퍼런스는 메모리를 직접 다루지 않기 때문에 안전하다
       - 코딩스타일면에서 reference는 일반적인 stack variable과 동일한 문법이기 때문에 이해하기 쉽다. (ex : *변수 같이 쓸 필요x)
       - 메모리의 소유권을 명확히 할 수 있다. 레퍼런스로 건내 받은 동적 할당 변수를 delete 하는건 애초에 불가능하다.